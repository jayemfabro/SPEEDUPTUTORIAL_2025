<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use App\Models\Admin\ClassModel;
use App\Services\NotificationService;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Validator;
use Carbon\Carbon;

class AdminClassController extends Controller
{
    /**
     * Display a listing of the classes.
     */
    public function index()
    {
        $classes = ClassModel::with('teacher')->get()->map(function ($class) {
            return [
                'id' => $class->id,
                'teacher_id' => $class->teacher_id,
                'teacher_name' => $class->teacher ? $class->teacher->name : null,
                'student_name' => $class->student_name,
                'class_type' => $class->class_type,
                'schedule' => $class->schedule,
                'time' => $class->time,
                'status' => $class->status,
                'created_at' => $class->created_at,
                'updated_at' => $class->updated_at
            ];
        });
        
        return response()->json($classes);
    }

    /**
     * Store a newly created class in storage.
     */
    public function store(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'teacher_id' => 'required|exists:users,id',
            'student_name' => 'required|string|max:255',
            'class_type' => 'required|string|max:50',
            'schedule' => 'required|date',
            'time' => 'required|string|max:50',
            'status' => 'required|string|max:50'
        ]);

        if ($validator->fails()) {
            return response()->json(['errors' => $validator->errors()], 422);
        }

        // Check for time conflicts for Regular and Premium classes
        if (in_array(strtolower($request->class_type), ['regular', 'premium'])) {
            $existingClass = ClassModel::where('teacher_id', $request->teacher_id)
                ->where('schedule', $request->schedule)
                ->where('time', $request->time)
                ->where('status', '!=', 'Cancelled')
                ->first();

            if ($existingClass) {
                return response()->json([
                    'error' => 'Time slot unavailable',
                    'message' => "The selected time slot is already occupied by {$existingClass->student_name} for a {$existingClass->class_type} class. Please choose a different time or convert to a Group class if multiple students are intended.",
                    'conflicting_class' => [
                        'student_name' => $existingClass->student_name,
                        'class_type' => $existingClass->class_type,
                        'time' => $existingClass->time,
                        'schedule' => $existingClass->schedule
                    ]
                ], 409); // 409 Conflict status code
            }
        }
        // Note: Group classes are allowed to have multiple students at the same time slot

        $class = ClassModel::create($request->all());

        // Automatically update student statistics in database
        $this->updateStudentStatsInDatabase($class->student_name);

        // Send notification to the assigned teacher
        NotificationService::createClassAssignedNotification($request->teacher_id, [
            'id' => $class->id,
            'student_name' => $class->student_name,
            'class_type' => $class->class_type,
            'start_time' => $class->schedule . ' ' . $class->time,
            'end_time' => $class->schedule . ' ' . $class->time, // You may want to calculate actual end time
        ]);

        // Determine success message based on class type
        $message = 'Class created successfully';
        if (strtolower($request->class_type) === 'group') {
            $message = 'Group class created successfully - multiple students can be added to this time slot';
        }

        return response()->json([
            'message' => $message,
            'class' => $class
        ], 201);
    }

    /**
     * Display the specified class.
     */
    public function show($id)
    {
        $class = ClassModel::with('teacher')->findOrFail($id);
        
        return response()->json([
            'id' => $class->id,
            'teacher_id' => $class->teacher_id,
            'teacher_name' => $class->teacher ? $class->teacher->name : null,
            'student_name' => $class->student_name,
            'class_type' => $class->class_type,
            'schedule' => $class->schedule,
            'time' => $class->time,
            'status' => $class->status,
            'created_at' => $class->created_at,
            'updated_at' => $class->updated_at
        ]);
    }

    /**
     * Update the specified class in storage.
     */
    public function update(Request $request, $id)
    {
        $validator = Validator::make($request->all(), [
            'teacher_id' => 'required|exists:users,id',
            'student_name' => 'required|string|max:255',
            'class_type' => 'required|string|max:50',
            'schedule' => 'required|date',
            'time' => 'required|string|max:50',
            'status' => 'required|string|max:50'
        ]);

        if ($validator->fails()) {
            return response()->json(['errors' => $validator->errors()], 422);
        }

        $class = ClassModel::findOrFail($id);
        $originalData = $class->toArray(); // Store original data

        // Check for time conflicts for Regular and Premium classes (excluding current class)
        if (in_array(strtolower($request->class_type), ['regular', 'premium'])) {
            $existingClass = ClassModel::where('teacher_id', $request->teacher_id)
                ->where('schedule', $request->schedule)
                ->where('time', $request->time)
                ->where('status', '!=', 'Cancelled')
                ->where('id', '!=', $id) // Exclude current class from conflict check
                ->first();

            if ($existingClass) {
                return response()->json([
                    'error' => 'Time slot unavailable',
                    'message' => "The selected time slot is already occupied by {$existingClass->student_name} for a {$existingClass->class_type} class. Please choose a different time or convert to a Group class if multiple students are intended.",
                    'conflicting_class' => [
                        'student_name' => $existingClass->student_name,
                        'class_type' => $existingClass->class_type,
                        'time' => $existingClass->time,
                        'schedule' => $existingClass->schedule
                    ]
                ], 409); // 409 Conflict status code
            }
        }

        $class->update($request->all());

        // Add this line to trigger stats recalculation
        $this->updateStudentStatsInDatabase($class->student_name);

        // Send notification to the teacher if the class was updated
        $changes = array_diff_assoc($request->all(), $originalData);
        if (!empty($changes)) {
            NotificationService::createClassUpdatedNotification($request->teacher_id, [
                'id' => $class->id,
                'student_name' => $class->student_name,
                'class_type' => $class->class_type,
                'start_time' => $class->schedule . ' ' . $class->time,
                'end_time' => $class->schedule . ' ' . $class->time,
            ], $changes);
        }

        // Determine success message based on class type
        $message = 'Class updated successfully';
        if (strtolower($request->class_type) === 'group') {
            $message = 'Group class updated successfully - multiple students can be added to this time slot';
        }

        return response()->json([
            'message' => $message,
            'class' => $class
        ]);
    }

    /**
     * Remove the specified class from storage.
     */
    public function destroy($id)
    {
        try {
            $class = ClassModel::findOrFail($id);
            $studentName = $class->student_name; // Store student name before deletion
            $class->delete();

            // Automatically update student statistics in database after deletion
            $this->updateStudentStatsInDatabase($studentName);

            return response()->json([
                'message' => 'Class deleted successfully'
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'message' => 'Failed to delete class',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Get classes for calendar view with optional teacher filter
     */
    public function getCalendarClasses(Request $request)
    {
        // Prevent duplicate/concurrent requests using a simple lock mechanism
        $lockKey = 'bulk_delete_' . auth()->id();
        $lockFile = storage_path("app/locks/{$lockKey}");
        
        if (file_exists($lockFile) && (time() - filemtime($lockFile)) < 10) {
            \Log::warning('Duplicate bulk delete request detected', [
                'user_id' => auth()->id(),
                'lock_age' => time() - filemtime($lockFile)
            ]);
            return response()->json([
                'message' => 'A bulk delete operation is already in progress. Please wait.'
            ], 429);
        }
        
        // Create lock file
        if (!is_dir(dirname($lockFile))) {
            mkdir(dirname($lockFile), 0755, true);
        }
        touch($lockFile);
        try {
            // Early validation checks
            if (!$request->isMethod('DELETE')) {
                \Log::warning('Invalid HTTP method for bulk delete', [
                    'method' => $request->method(),
                    'ip' => $request->ip()
                ]);
                return response()->json(['message' => 'Method not allowed'], 405);
            }

            if (!$request->expectsJson()) {
                \Log::warning('Non-JSON request to bulk delete endpoint', [
                    'accept_header' => $request->header('Accept'),
                    'content_type' => $request->header('Content-Type')
                ]);
            }

            // Log debugging information
            \Log::debug('Bulk destroy request received', [
                'is_authenticated' => auth()->check(),
                'user_role' => auth()->check() ? auth()->user()->role : 'not logged in',
                'request_content_type' => $request->header('Content-Type'),
                'request_accept' => $request->header('Accept'),
                'request_data' => $request->all(),
                'request_size' => strlen(json_encode($request->all())),
                'ip' => $request->ip()
            ]);
            
            if (!auth()->check()) {
                \Log::warning('Unauthenticated user attempted to delete classes', [
                    'ip' => $request->ip(),
                    'user_agent' => $request->userAgent()
                ]);
                
                return response()->json([
                    'message' => 'Unauthenticated. Please sign in again to manage classes.'
                ], 401);
            }

            if (!auth()->user()->isAdmin()) {
                \Log::warning('Non-admin user attempted to delete classes', [
                    'user_id' => auth()->id(),
                    'role' => auth()->user()->role
                ]);
                
                return response()->json([
                    'message' => 'You do not have permission to delete classes.'
                ], 403);
            }

            // Additional request validation
            $requestData = $request->all();
            if (empty($requestData)) {
                \Log::error('Empty request data received for bulk delete');
                return response()->json([
                    'message' => 'No data received. Please try again.'
                ], 400);
            }

            // Check for maximum deletion limit to prevent abuse
            if (isset($requestData['class_ids']) && is_array($requestData['class_ids']) && count($requestData['class_ids']) > 100) {
                \Log::warning('Attempted to delete too many classes at once', [
                    'count' => count($requestData['class_ids']),
                    'user_id' => auth()->id()
                ]);
                return response()->json([
                    'message' => 'Cannot delete more than 100 classes at once. Please select fewer classes.'
                ], 422);
            }

            $validated = $request->validate([
                'class_ids' => ['required', 'array', 'min:1', 'max:100'],
                'class_ids.*' => ['integer', 'exists:classes,id'],
            ]);

            $classIds = $validated['class_ids'];

            $deletedCount = 0;

            // Test database connection before proceeding
            try {
                DB::connection()->getPdo();
                \Log::debug('Database connection verified');
            } catch (\Exception $e) {
                \Log::error('Database connection failed', [
                    'error' => $e->getMessage()
                ]);
                return response()->json([
                    'message' => 'Database connection error. Please try again.'
                ], 503);
            }

            // Log the class IDs we're about to delete
            \Log::info('Starting bulk delete transaction', [
                'class_count' => count($classIds),
                'class_ids' => $classIds,
                'user_id' => auth()->id()
            ]);

            DB::transaction(function () use ($classIds, &$deletedCount) {
                $classes = ClassModel::whereIn('id', $classIds)->get();
                
                // Log what we found
                \Log::info('Found classes to delete', [
                    'found_count' => $classes->count(),
                    'found_ids' => $classes->pluck('id')->toArray()
                ]);
                
                $studentNames = $classes->pluck('student_name')->filter()->unique();
                \Log::info('Student names that will need stat updates', [
                    'count' => $studentNames->count(),
                    'names' => $studentNames->toArray()
                ]);

                $deletedCount = ClassModel::whereIn('id', $classIds)->delete();
                
                \Log::info('Classes deleted', [
                    'deleted_count' => $deletedCount
                ]);

                foreach ($studentNames as $studentName) {
                    try {
                        \Log::info('Updating stats for student', ['student_name' => $studentName]);
                        $this->updateStudentStatsInDatabase($studentName);
                    } catch (\Exception $e) {
                        \Log::error('Failed to update stats for student', [
                            'student_name' => $studentName,
                            'error' => $e->getMessage()
                        ]);
                        // Continue with other students even if one fails
                    }
                }
            });

            \Log::info('Bulk delete completed successfully', [
                'deleted_count' => $deletedCount
            ]);
            
            // Clean up lock file
            $lockKey = 'bulk_delete_' . auth()->id();
            $lockFile = storage_path("app/locks/{$lockKey}");
            if (file_exists($lockFile)) {
                unlink($lockFile);
            }
            
            return response()->json([
                'message' => "Successfully deleted {$deletedCount} class(es)",
                'deleted_count' => $deletedCount
            ]);
        } catch (\Illuminate\Validation\ValidationException $e) {
            \Log::error('Validation error during bulk delete', [
                'errors' => $e->errors(),
                'message' => $e->getMessage(),
                'request_data' => $request->all()
            ]);
            
            return response()->json([
                'message' => 'Validation failed',
                'errors' => $e->errors()
            ], 422);
        } catch (\Illuminate\Database\QueryException $e) {
            \Log::error('Database error during bulk delete', [
                'message' => $e->getMessage(),
                'sql' => $e->getSql() ?? 'Unknown',
                'bindings' => $e->getBindings() ?? [],
                'error_code' => $e->errorInfo[1] ?? 'Unknown'
            ]);
            
            return response()->json([
                'message' => 'Database error occurred while deleting classes',
                'error' => 'Please try again or contact support if the issue persists'
            ], 500);
        } catch (\Exception $e) {
            \Log::error('Exception during bulk delete', [
                'message' => $e->getMessage(),
                'file' => $e->getFile(),
                'line' => $e->getLine(),
                'trace' => $e->getTraceAsString(),
                'request_data' => $request->all(),
                'user_id' => auth()->id()
            ]);
            
            return response()->json([
                'message' => 'Failed to delete classes',
                'error' => config('app.debug') ? $e->getMessage() : 'An unexpected error occurred'
            ], 500);
        } finally {
            // Always clean up lock file
            $lockKey = 'bulk_delete_' . auth()->id();
            $lockFile = storage_path("app/locks/{$lockKey}");
            if (file_exists($lockFile)) {
                unlink($lockFile);
            }
        }
    }

    /**
     * Get classes for calendar view with optional teacher filter
     */
    public function getCalendarClasses(Request $request)
    {
        try {
            $query = ClassModel::with('teacher');
            
            // Filter by teacher if provided
            if ($request->has('teacher_id') && $request->teacher_id !== 'all') {
                $query->where('teacher_id', $request->teacher_id);
            }
            
            // Filter by date range if provided
            if ($request->has('start_date') && $request->has('end_date')) {
                $query->whereBetween('schedule', [$request->start_date, $request->end_date]);
            }
            
            $classes = $query->get()->map(function ($class) {
                // Transform the data to match calendar format
                $schedule = \Carbon\Carbon::parse($class->schedule);
                $dayName = $schedule->format('l'); // Monday, Tuesday, etc.
                
                return [
                    'id' => $class->id,
                    'student_name' => $class->student_name,
                    'teacher_id' => $class->teacher_id,
                    'teacher_name' => $class->teacher ? $class->teacher->name : null,
                    'day' => $dayName,
                    'time' => $class->time,
                    'duration' => 30, // Default duration, could be added to database
                    'class_type' => $class->class_type,
                    'status' => $class->status,
                    'date' => $schedule->toDateString(),
                    'schedule' => $class->schedule,
                ];
            });
            
            return response()->json($classes);
        } catch (\Exception $e) {
            return response()->json(['error' => 'Failed to fetch classes', 'message' => $e->getMessage()], 500);
        }
    }

    /**
     * Update student statistics in database based on class records
     *
     * @param string|null $studentName
     * @return void
     */
    private function updateStudentStatsInDatabase($studentName)
    {
        if (empty($studentName)) {
            \Log::warning("Empty student name provided for stats update");
            return;
        }

        try {
            // Clean the student name by removing surrounding quotes if they exist
            $cleanStudentName = trim($studentName, '"');
            \Log::info("Looking up student", ['original_name' => $studentName, 'cleaned_name' => $cleanStudentName]);
            
            // Get the student record using cleaned name
            $student = \App\Models\Admin\Student::where('name', $cleanStudentName)->first();
            
            if (!$student) {
                \Log::warning("Student not found for auto-update", ['original_name' => $studentName, 'cleaned_name' => $cleanStudentName]);
                return;
            }

            // Use the AdminStudentController's calculation method with cleaned name
            $adminController = new \App\Http\Controllers\Admin\AdminStudentController();
            $calculatedStats = $adminController->calculateStudentStats($cleanStudentName);

            // Check if we have valid stats before updating
            if (!is_array($calculatedStats)) {
                \Log::warning("Invalid stats returned for student", ['student_name' => $cleanStudentName, 'original_name' => $studentName]);
                return;
            }

            // Ensure all required keys exist in the array to prevent null reference errors
            $requiredKeys = ['completed', 'cancelled', 'free_classes', 'free_class_consumed', 'absent_w_ntc_counted', 'class_left'];
            foreach ($requiredKeys as $key) {
                if (!isset($calculatedStats[$key])) {
                    $calculatedStats[$key] = 0;
                    \Log::warning("Missing stat key '{$key}' for student {$cleanStudentName}, defaulting to 0");
                }
            }

            // Update the student record with calculated values
            $student->update([
                'completed' => $calculatedStats['completed'],
                'cancelled' => $calculatedStats['cancelled'],
                'free_classes' => $calculatedStats['free_classes'],
                'free_class_consumed' => $calculatedStats['free_class_consumed'],
                'absent_w_ntc_counted' => $calculatedStats['absent_w_ntc_counted'],
                'class_left' => $calculatedStats['class_left']
            ]);

            \Log::info("Student stats automatically updated in database", [
                'student_name' => $studentName,
                'updated_stats' => $calculatedStats
            ]);

        } catch (\Exception $e) {
            \Log::error("Failed to auto-update student stats in database: " . $e->getMessage(), [
                'student_name' => $studentName,
                'exception_trace' => $e->getTraceAsString()
            ]);
        }
    }
}